## 构建与运行

在提交任何变更之前，通过运行完整的预检（preflight check）来验证它们是至关重要的。该命令将构建仓库、运行所有测试、检查类型错误并对代码进行 lint。

要运行完整的检查套件，请执行以下命令：

```bash
npm run preflight
```

这个单一命令可确保您的变更符合项目的所有质量门槛。虽然您可以单独运行各个步骤（`build`、`test`、`typecheck`、`lint`），但强烈建议使用 `npm run preflight` 以确保进行全面验证。

## 编写测试

本项目使用 **Vitest** 作为其主要测试框架。在编写测试时，请遵循现有模式。关键约定包括：

### 测试结构与框架

- **框架**: 所有测试均使用 Vitest（`describe`、`it`、`expect`、`vi`）编写。
- **文件位置**: 测试文件（逻辑部分为 `*.test.ts`，React 组件为 `*.test.tsx`）与其测试的源文件并置存放。
- **配置**: 测试环境在 `vitest.config.ts` 文件中定义。
- **设置/拆卸**: 使用 `beforeEach` 和 `afterEach`。通常，在 `beforeEach` 中调用 `vi.resetAllMocks()`，在 `afterEach` 中调用 `vi.restoreAllMocks()`。

### 模拟（Mocking）（来自 Vitest 的 `vi`）

- **ES 模块**: 使用 `vi.mock('module-name', async (importOriginal) => { ... })` 进行模拟。使用 `importOriginal` 进行选择性模拟。
  - _示例_: `vi.mock('os', async (importOriginal) => { const actual = await importOriginal(); return { ...actual, homedir: vi.fn() }; });`
- **模拟顺序**: 对于影响模块级常量的关键依赖项（例如 `os`、`fs`），请将 `vi.mock` 放置在测试文件的*最顶部*，在其他导入之前。
- **提升（Hoisting）**: 如果一个模拟函数需要在 `vi.mock` 工厂函数中使用之前被定义，请使用 `const myMock = vi.hoisted(() => vi.fn());`。
- **模拟函数**: 使用 `vi.fn()` 创建。使用 `mockImplementation()`、`mockResolvedValue()` 或 `mockRejectedValue()` 定义其行为。
- **侦测（Spying）**: 使用 `vi.spyOn(object, 'methodName')`。在 `afterEach` 中使用 `mockRestore()` 恢复侦测。

### 常用模拟模块

- **Node.js 内置模块**: `fs`、`fs/promises`、`os` (特别是 `os.homedir()`)、`path`、`child_process` (`execSync`, `spawn`)。
- **外部 SDK**: `@google/genai`、`@modelcontextprotocol/sdk`。
- **内部项目模块**: 来自其他项目包的依赖项通常会被模拟。

### React 组件测试 (CLI UI - Ink)

- 使用 `ink-testing-library` 中的 `render()`。
- 使用 `lastFrame()` 断言输出。
- 将组件包裹在必要的 `Context.Provider` 中。
- 使用 `vi.mock()` 模拟自定义 React 钩子和复杂的子组件。

### 异步测试

- 使用 `async/await`。
- 对于计时器，使用 `vi.useFakeTimers()`、`vi.advanceTimersByTimeAsync()`、`vi.runAllTimersAsync()`。
- 使用 `await expect(promise).rejects.toThrow(...)` 测试 Promise 拒绝。

### 通用指南

- 添加测试时，首先检查现有测试以理解并遵循既定约定。
- 密切关注现有测试文件顶部的模拟，它们揭示了关键依赖项及其在测试环境中的管理方式。

## Git 仓库

本项目的主分支名为 "main"。

## JavaScript/TypeScript

在为这个 React、Node 和 TypeScript 代码库做贡献时，请优先使用带有 TypeScript 接口或类型声明的纯 JavaScript 对象，而不是 JavaScript 的 class 语法。这种方法具有显著优势，尤其是在与 React 的互操作性和整体代码可维护性方面。

### 偏好纯对象而非类

JavaScript 的类，就其本质而言，旨在封装内部状态和行为。虽然这在某些面向对象的范式中可能很有用，但在使用 React 的基于组件的架构时，它常常会引入不必要的复杂性和摩擦。以下是偏好纯对象的原因：

- **无缝的 React 集成**: React 组件在显式的 props 和状态管理上表现出色。类倾向于将内部状态直接存储在实例中，这会使 prop 和状态的传播更难推理和维护。另一方面，纯对象（如果使用得当）本质上是不可变的，并且可以轻松地作为 props 传递，从而简化数据流并减少意外的副作用。

- **减少样板代码并提高简洁性**: 类通常会促进构造函数、this 绑定、getter、setter 和其他样板代码的使用，这会不必要地使代码膨胀。TypeScript 接口和类型声明提供了强大的静态类型检查，而没有类定义的运行时开销或冗长。这使得代码更简洁、更易读，符合 JavaScript 在函数式编程方面的优势。

- **增强的可读性和可预测性**: 纯对象，特别是当其结构由 TypeScript 接口清晰定义时，通常更易于阅读和理解。它们的属性是直接可访问的，没有隐藏的内部状态或复杂的继承链需要导航。这种可预测性可以减少错误并提高代码库的可维护性。

- **简化的不可变性**: 虽然没有严格强制，但纯对象鼓励对数据采用不可变的方法。当您需要修改对象时，通常会创建一个包含所需更改的新对象，而不是改变原始对象。这种模式与 React 的协调过程完美契合，有助于防止与共享可变状态相关的细微错误。

- **更好的序列化和反序列化**: 纯 JavaScript 对象天然易于序列化为 JSON 并反序列化回来，这是 Web 开发中的常见需求（例如，用于 API 通信或本地存储）。而带有方法和原型的类会使这个过程复杂化。

### 拥抱 ES 模块语法进行封装

我们强烈建议利用 ES 模块语法（`import`/`export`）来封装私有和公共 API，而不是依赖于类似 Java 的 private 或 public 类成员，后者可能很冗长，有时还会限制灵活性。

- **更清晰的公共 API 定义**: 使用 ES 模块，任何导出的内容都是该模块公共 API 的一部分，而任何未导出的内容本质上都是该模块的私有部分。这提供了一种非常清晰和明确的方式来定义代码的哪些部分旨在供其他模块使用。

- **增强的可测试性（不暴露内部实现）**: 默认情况下，未导出的函数或变量无法从模块外部访问。这鼓励您测试模块的公共 API，而不是其内部实现细节。如果您发现自己为了测试目的需要侦测或存根（stub）一个未导出的函数，这通常是一种“代码异味”，表明该函数可能适合提取到其自己的、具有明确定义的公共 API 的独立可测试模块中。这促进了更健壮和可维护的测试策略。

- **减少耦合**: 通过 import/export 明确定义的模块边界有助于减少代码库不同部分之间的耦合。这使得重构、调试和理解隔离的单个组件变得更加容易。

### 避免 `any` 类型和类型断言；偏好 `unknown`

TypeScript 的强大之处在于其提供静态类型检查的能力，可以在代码运行前捕获潜在错误。为了充分利用这一点，避免使用 `any` 类型并审慎使用类型断言至关重要。

- **`any` 的危险**: 使用 `any` 实际上是为该特定变量或表达式选择退出 TypeScript 的类型检查。虽然短期内可能看起来很方便，但它会带来重大风险：
  - **类型安全性的丧失**: 您将失去类型检查的所有好处，从而很容易引入 TypeScript 本可以捕获的运行时错误。
  - **可读性和可维护性降低**: 带有 `any` 类型的代码更难理解和维护，因为预期的数据类型不再被明确定义。
  - **掩盖潜在问题**: 通常，对 `any` 的需求表明您的代码设计或与外部库交互的方式存在更深层次的问题。这是一个信号，表明您可能需要优化您的类型或重构您的代码。

- **偏好 `unknown` 而非 `any`**: 当您在编译时绝对无法确定值的类型，并且想使用 `any` 时，请考虑改用 `unknown`。`unknown` 是 `any` 的类型安全对应物。虽然 `unknown` 类型的变量可以持有任何值，但在对其执行任何操作之前，您必须执行类型收窄（例如，使用 `typeof` 或 `instanceof` 检查，或类型断言）。这迫使您显式处理 `unknown` 类型，从而防止意外的运行时错误。

  ```
  function processValue(value: unknown) {
     if (typeof value === 'string') {
        // value 现在可以安全地作为字符串使用
        console.log(value.toUpperCase());
     } else if (typeof value === 'number') {
        // value 现在可以安全地作为数字使用
        console.log(value * 2);
     }
     // 如果不进行类型收窄，您将无法访问 'value' 上的属性或方法
     // console.log(value.someProperty); // 错误：对象类型为 'unknown'。
  }
  ```

- **类型断言 (`as Type`) - 谨慎使用**: 类型断言告诉 TypeScript 编译器：“相信我，我知道我在做什么；这绝对是这个类型。” 虽然存在合法用例（例如，在处理没有完美类型定义的外部库时，或者当您拥有比编译器更多的信息时），但应谨慎使用，并极度小心。
  - **绕过类型检查**: 与 `any` 一样，类型断言会绕过 TypeScript 的安全检查。如果您的断言不正确，您将引入一个 TypeScript 不会警告您的运行时错误。
  - **测试中的代码异味**: 在试图测试“私有”实现细节（例如，侦测或存根模块内未导出的函数）时，`any` 或类型断言可能很诱人。这是测试策略和潜在代码结构中存在“代码异味”的强烈迹象。与其试图强制访问私有内部实现，不如考虑是否应将这些内部细节重构为一个具有明确定义的公共 API 的独立模块。这使它们在不损害封装性的情况下具有内在的可测试性。

### 拥抱 JavaScript 的数组操作符

为了进一步提高代码的整洁性并促进安全的函数式编程实践，请尽可能多地利用 JavaScript 丰富的数组操作符。像 `.map()`、`.filter()`、`.reduce()`、`.slice()`、`.sort()` 等方法在以不可变和声明式的方式转换和操作数据集合方面非常强大。

使用这些操作符：

- **促进不可变性**: 大多数数组操作符返回新数组，保持原始数组不变。这种函数式方法有助于防止意外的副作用，并使您的代码更具可预测性。
- **提高可读性**: 链接数组操作符通常比传统的 for 循环或命令式逻辑产生更简洁、更具表现力的代码。操作的意图一目了然。
- **促进函数式编程**: 这些操作符是函数式编程的基石，鼓励创建接收输入并产生输出而不会引起副作用的纯函数。这种范式对于编写与 React 配合良好的健壮且可测试的代码非常有益。

通过始终如一地应用这些原则，我们可以维护一个不仅高效、高性能，而且在现在和未来都令人愉快地使用的代码库。

## React (镜像并调整自 [react-mcp-server](https://github.com/facebook/react/blob/4448b18760d867f9e009e810571e7a3b8930bb19/compiler/packages/react-mcp-server/src/index.ts#L376C1-L441C94))

### 角色

您是一个 React 助手，帮助用户编写更高效、更可优化的 React 代码。您专注于识别能够让 React 编译器自动应用优化、减少不必要的重新渲染并提高应用程序性能的模式。

### 在您生成和建议的所有代码中遵循这些准则

使用带有 Hooks 的函数式组件：不要生成类组件或使用旧的生命周期方法。使用 `useState` 或 `useReducer` 管理状态，使用 `useEffect`（或相关 Hooks）处理副作用。对于任何新的组件逻辑，始终偏好函数和 Hooks。

在渲染期间保持组件纯净且无副作用：不要在组件函数体内直接编写执行副作用（如订阅、网络请求或修改外部变量）的代码。此类操作应包装在 `useEffect` 中或在事件处理程序中执行。确保您的渲染逻辑是 props 和 state 的纯函数。

尊重单向数据流：通过 props 向下传递数据，并避免任何全局突变。如果两个组件需要共享数据，请将该状态提升到共同的父组件或使用 React Context，而不是试图同步本地状态或使用外部变量。

永远不要直接改变状态：始终生成以不可变方式更新状态的代码。例如，在更新状态时使用扩展语法或其他方法创建新的对象/数组。不要在状态变量上使用 `state.someValue = ...` 之类的赋值或 `array.push()` 之类的数组突变。使用状态设置器（来自 `useState` 的 `setState` 等）来更新状态。

准确使用 `useEffect` 和其他 effect Hooks：每当您认为可以使用 `useEffect` 时，请更深入地思考以避免它。`useEffect` 主要仅用于同步，例如将 React 与某些外部状态同步。重要提示 - 不要在 `useEffect` 中调用 `setState`（`useState` 返回的第二个值），因为这会降低性能。在编写 effect 时，请在依赖项数组中包含所有必要的依赖项。不要抑制 ESLint 规则或省略 effect 代码使用的依赖项。正确构造 effect 回调以处理值的变化（例如，在 prop 更改时更新订阅，在卸载或依赖项更改时进行清理）。如果一段逻辑只应在响应用户操作（如表单提交或按钮单击）时运行，请将该逻辑放在事件处理程序中，而不是 `useEffect` 中。在可能的情况下，`useEffect` 应返回一个清理函数。

遵循 Hooks 的规则：确保任何 Hooks（`useState`、`useEffect`、`useContext`、自定义 Hooks 等）都在 React 函数组件或其他 Hooks 的顶层无条件调用。不要在循环、条件语句或嵌套辅助函数内部生成调用 Hooks 的代码。不要在非组件函数或 React 组件渲染上下文之外调用 Hooks。

仅在必要时使用 refs：避免使用 `useRef`，除非任务确实需要它（例如聚焦控件、管理动画或与非 React 库集成）。不要使用 refs 存储应具有反应性的应用程序状态。如果确实使用 refs，切勿在组件渲染期间写入或读取 `ref.current`（除了像延迟初始化这样的初始设置）。任何 ref 的使用都不应直接影响渲染的输出。

偏好组合和小型组件：将 UI 分解为小型、可重用的组件，而不是编写大型的单体组件。您生成的代码应通过组合组件来提高清晰度和可重用性。同样，在适当时将重复逻辑抽象为自定义 Hooks 以避免代码重复。

为并发性进行优化：假设 React 可能会出于调度目的多次渲染您的组件（尤其是在开发中使用严格模式时）。编写即使组件函数运行多次也能保持正确的代码。例如，避免在组件主体中产生副作用，并在基于先前状态更新状态时使用函数式状态更新（例如 `setCount(c => c + 1)`）以防止竞争条件。始终在订阅外部资源的 effect 中包含清理函数。不要为“当此更改时执行此操作”的副作用编写 `useEffect`。这可确保您生成的代码能够与 React 的并发渲染功能一起正常工作而不会出现问题。

优化以减少网络瀑布流 - 尽可能使用并行数据获取（例如，一次启动多个请求而不是一个接一个）。利用 Suspense 进行数据加载，并将请求与需要数据的组件放在一起。在以服务器为中心的方法中，在服务器端（例如，使用服务器组件）的单个请求中一起获取相关数据以减少往返次数。此外，考虑使用缓存层或全局获取管理来避免重复相同的请求。

依赖 React 编译器 - 如果启用了 React 编译器，则可以省略 `useMemo`、`useCallback` 和 `React.memo`。避免使用手动记忆化进行过早优化。相反，专注于编写具有直接数据流和无副作用渲染函数的清晰、简单的组件。让 React 编译器处理摇树优化（tree-shaking）、内联和其他性能增强，以使您的代码库更简单、更易于维护。

为良好的用户体验而设计 - 提供清晰、简约且非阻塞的 UI 状态。在数据加载时，显示轻量级占位符（例如骨架屏），而不是到处都是侵入性的加载指示器。使用专用的错误边界或友好的内联消息优雅地处理错误。在可能的情况下，在数据可用时渲染部分数据，而不是让用户等待所有内容。Suspense 允许您以自然的方式在组件树中声明加载状态，从而防止“闪烁”状态并提高感知性能。

### 流程

1.  分析用户的代码以寻找优化机会：
    - 检查妨碍编译器优化的 React 反模式
    - 寻找限制编译器效率的组件结构问题
    - 思考您提出的每条建议，并查阅 React 文档以获取最佳实践

2.  提供可行的指导：
    - 用清晰的理由解释具体的代码更改
    - 在建议更改时显示前后对比示例
    - 仅建议能有意义地提高优化潜力的更改

### 优化指南

- 状态更新的结构应能实现粒度更新
- 副作用应被隔离，并明确定义依赖关系

## 注释策略

只在必要时编写高价值的注释。避免通过注释与用户交谈。

## 通用样式要求

在标志名称中使用连字符而不是下划线（例如 `my-flag` 而不是 `my_flag`）。
